# 背包问题

## 0. 问题形式

一般而言，背包问题的共同点是，有 `N` 种不同的物品，每种大小为 `c[i]`, 权重为 `w[i]`, 有 `n[i]` 个；需要装进体积为 `V` 的背包。

对于需要求解的问题，可以大致分解为以下几种：

- 可行性（是否存在一种装法能恰好装满背包？）

- 装法数量（存在多少装法可以恰好装满背包？）

- 最优权重（如何选择物品使 *（可选：在恰好装满时）* 物品总权重最大）

- 最小数量（如何选择物品使在恰好装满时物品总数最小）

- …………

对于不同的 `n[i]`, 也有以下几种情况：

- `n[i] = 1`, 即 0-1 背包问题

- `n[i] = INF`, 即完全背包问题

- `n[i] = k > 1`, 即多重背包问题

对于不同物品属于不同子问题的情况下，可以对于不同物品套用不同的模板。

不失一般性，在以下章节中我们默认讨论**不要求恰好装满的最优权重**，事实上针对其他的问题定义可以相应对状态转移方程的形式进行修改。

## 1. 0-1 背包问题

作为动态规划问题，我们本质上要定义**状态**和**选择**。对于状态，一种简便直观的方案是，定义 `dp[i][v]` 为考虑前 `i` 个物品装入容量为 `v` 的背包的最大权重。那么，对应的选择就是

- 装入第 `i` 个物品（如果装得下， `v >= c[i]` ，下略）， `dp[i][v] = dp[i-1][v-c[i]] + w[i]`

- 不装入第 `i` 个物品， `dp[i][v] = dp[i-1][v]`

那么，不考虑边界条件，转移方程可以写成: `dp[i][v] = max(dp[i-1][v], dp[i-1][v-c[i]] + w[i])`.

整体的循环可以写成

```python
for i in range(N):
    for v in range(c[i], V + 1):
        dp[i][v] = max(dp[i-1][v], dp[i-1][v-c[i]] + w[i])
```

这样的时间和空间复杂度均为 $O(VN)$. 显然 `i` 的状态都依赖于 `i - 1` 的状态，那么可以进行状态压缩，将空间复杂度压缩为 $O(V)$.

压缩后的循环为：

```python
# 0-1 backpack
for i in range(N):
    for v in range(V， c[i] - 1, -1): # in REVERSE order
        dp[v] = max(dp[v], dp[v-c[i]] + w[i])
```

注意这里再内层循环中使用了**逆序**遍历，相当于从后往前更新，这样保证了更新位置之前的部分都是上一个循环里的。如果再相对实际问题考虑一下，因为每种物品只能取**一次**，那么如果从前向后更新的话，相当于会存在同一个物品被取了多次的可能，不符合要求。

### 代表题目

- [LC416](https://leetcode-cn.com/problems/partition-equal-subset-sum/) 本质是可行性问题，粗略判断后直接套模板。

- [LC494](https://leetcode-cn.com/problems/target-sum) 本质是数量问题，同样可以在确定新的空背包定义后套用模板。

## 2. 完全背包问题

完全背包就是每一种物品可以无限制拿取，当然由于背包空间有限，实际上拿去的数量有上界 `floor(V / c[i])`, 那么我们就可以确定如下的转移方程：

`dp[i][v] = max(dp[i-1][v-k*c[i]] | 0 <= k*c[i] < v)`

参考一下上一节的 0-1 背包问题，我们可以考虑相同的 `floor(V / c[i])` 个物品，然后套用 0-1 背包的解法。这样的时间复杂度是 $O(V \sum_i (V/c[i])$.

那么如何优化呢，最直观的想法是用一套编码来**编码**取到不同数量该物品的方案。那么事实上我们可以定义 `floor(log2(V / c[i]) + 1)` 种不同物品，套用前述方案，使得时间复杂度降至 $O(V \log (\sum_i (V/c[i]))$.

那么有没有更快的方案呢，实际上是有的。从前面讲 0-1 背包为何使用倒序遍历的逻辑，我们很容易知道，**正序**遍历实际上就是相当于该物品不限量。那么，我们可以写出循环：

```python
# full backpack
for i in range(N):
    for v in range(c[i], V + 1): 
        dp[v] = max(dp[v], dp[v-c[i]] + w[i])
```

### 代表题目

- [LC322](https://leetcode-cn.com/problems/coin-change/) 完全背包最小数量，套模板，注意数组初始值和判断是否存在可行解。

- [LC518](https://leetcode-cn.com/problems/coin-change-2/) 完全背包方案总数，套模板。

## 3. 多重背包问题

根据前一节的叙述，我们可以知道，在某个物品限定个数**大于等于** `floor(V / c[i])` 时，对于该物品而言实际可看作并没有数量限制，就是完全背包问题。而**小于**的情况，我们就可以使用对数级别的编码算法拆分物品。

## 4. 多维背包问题

按照前述定义多维 `dp` 数组即可，转移方程和循环方式如法炮制。

有一种情况是对于物品数量的限制，这种也可以看作增维的背包问题（增加了物品个数维度）

### 代表题目

- [LC474](https://leetcode-cn.com/problems/ones-and-zeroes) 二维 0-1 背包问题，依旧套模板。

## 5. 混合背包问题

对于不同物品要求不同的情况，对于每种物品单独用对应的方案处理即可（见招拆招）。

## 6. 用 DFS 解决背包问题

简单的 DFS 模板如下（以 0-1 背包为例），时间复杂度约为 $O(2^N)$ ：

```python
# DFS
def dfs(i, cur_v, cur_w):
    if cur_w > best:
        best = cur_w
    if i > N: # to end
        return
    for j in range(i, N):
        if cur_v + c[i] <= V:
            dfs(j + 1, cur_v + c[i], cur_w + w[i])
```
### 剪枝

- 最优性

- 可行性 

### 搜索顺序

- 按照效率排序，有利于最优性剪枝

- 按照物品大小排序，有利于可行性剪枝

- 乱序，有利于排坑（？

### 搜索和 DP 的取舍问题

- `N` 很大，则优先 DP, `V` 很大，则优先 DFS.

- 如果 DP 难以构造，可以先使用 DFS 试试。

## 参考文献

- [背包九讲](https://github.com/tianyicui/pack), Tianyi Cui.