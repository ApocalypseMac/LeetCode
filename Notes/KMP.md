# KMP 算法

## 0. 这是什么，有什么用

KMP 算法，是由 Knuth, Morris, Pratt 三人设计的线性时间字符串匹配方法。

在编辑文本程序过程中，我们经常需要找到文本中某个字符串（模式）的所有出现位置。这是，如果使用暴力匹配的算法，由于每一次遇到失配都会从起点的下一个字符重新开始，时间复杂度会达到 $O(mn)$ 的量级，当 $m, n$ 很大时，这样的时间复杂度是难以接受的。因此，我们需要对模式进行特征提取以提高匹配效率。

## 1. KMP 的核心，部分匹配表 (PMT)

### 1.1 概念

|String|a|b|a|b|a|c|a|
|------|-|-|-|-|-|-|-|
|Index |0|1|2|3|4|5|6|
|PMT   |0|0|1|2|3|0|1|

上表就是一个字符串及其对应的 PMT 数组的实例。这里 PMT 数组的定义就是（从字符串开头到该字符的）子串中**前缀**集合和**后缀**集合交集元素中的**最大**长度。

首先定义一下前/后缀集合。以上表的字符串为例，考虑 `s[0:4]`, 也就是 `"abab"`, 那么这个子串的前缀集合就是（注意该集合**不包含自身**）：

- `perfix_set = {s[0:1], s[0:2], s[0:3]} = {"a", "ab", "aba"}`,

- `suffix_set = {s[1:4], s[2:4], s[3:4]} = {"bab", "ab", "b"}`.

那么显然可见，这里两个集合的交集是 `{"ab"}`, 其元素最大长度为 2, 那么我们有 `PMT[3] = 2`.

类似地，我们就可以求出整个字符串的 PMT 数组。

### 1.2 求解方法

首先对于一个字符串，其 `PMT[0]` 一定为 `0`. 这是显而易见的，因为对于单个字符的前缀和后缀集合均为空集。

那么怎么求解 PMT 数组的后续元素呢？既然要找相等的前缀和后缀，那么我们可以通过平移这个字符串的拷贝来检查前后缀是否相等。这里暴力方法就是对于每个子串逐格平移并验证，其时间复杂度为 $O(m^3)$（当然也可以用类似暴力字符串匹配的方法优化到 $O(m^2)$）, 这样的时间复杂度显然是不满足要求的。那么我们优化的时候，就需要用前面已经得知的字符串信息（ PMT 数组）来优化失配时的后退步数。

以上节示例中的数组为例，我们可以考虑这个字符串上的两个指针 `i, j`, 对应一个字符串和它的拷贝 (`s, s'`) 的匹配位置。首先我们要求解的是 `PMT[1]`, 那么就将拷贝数组向右平移一格，将 `s[1]` 与 `s'[0]` 进行匹配 (`i = 1, j = 0`)。

这里显然 `s[1] != s'[0]`, 两者是不匹配的，那么按照暴力解法，我们应该将 `s'` 继续向右平移一格，并将 `j` 置零，`i` 对应做出改变。这样，

- `i = 2, j = 0, PMT[1] = 0`.

继续看，`s[2] == s'[0]`, 此时两者匹配成功，那么我们保持数组位置不变，将两个指针均向右移动一格，

- `i = 3, j = 1, PMT[2] = 1`.

如法炮制，我们有：

- `i = 4, j = 2, PMT[3] = 2`.

- `i = 5, j = 3, PMT[4] = 3`.

接下来，我们发现 `s[5] != s'[3]`, 此时按照暴力方法我们应该将两个指针回滚为 `i = 3, j = 0`，但是这样我们就没有应用到之前总结数组的信息了。这里我们考虑已经匹配的两个子串 `s[2:5], s'[0:3]`, 我们需要寻找**最小的平移距离**使得这（两）个子串的前后缀依然互相匹配。

注意到这里最小的平移距离代表着**最长的公共前后缀**，此时我们想到了这个子串的 PMT数组。巧合的是，我们事实上已经计算过这个子串的 PMT 数组，亦即 `PMT[0:3]`, 那么我们就可以直接得出这个子串的最长公共前后缀 `PMT[j-1], i.e. PMT[2]`. 那么平移后， `i` 指针不改变， `j` 指针回退到 `PMT[j-1]`, 继续对两个指针位置进行匹配：

- `i = 5, j = 1, s[i] != s'[j]`,

这里平移后有一次失配，继续按照之前的方式迭代：

- `i = 5, j = 0, s[i] != s'[j]`，

- `i = 6, j = 0, PMT[5] = 0`.

后面的部分就按照之前的规则匹配即可：

- `i = 7, j = 1, PMT[6] = 1`.

该过程的代码如下：

```python
def pmt(s: str):
    m = len(s)
    ans = [0] * m
    i, j = 1, 0
    while i < n:
        if s[i] == s[j]: # matched
            j += 1
            i += 1
            ans[i - 1] = j
        elif j == 0: # not match, j == 0
            i += 1
            ans[i - 1] = j
        else: # not match, general
            j = ans[j - 1]
    return ans
```

上述算法的时间复杂度为 $O(m)$ [^1]

[^1]: 这里对于复杂度的证明从略，可以参考 CLRS 32.4. 事实上通过 PMT 数组的增长特性我们就可以发现，指针 `j` 回跳的次数为 O(m) 次。



## 2. 回到 KMP 算法

事实上，我们前面提到的求解一个字符串的 PMT 的过程，本身就是 KMP 算法的一个特例：主字符串和目标字符串均为该字符串。那么对于一般的情况，在求得目标字符串的 PMT 表后，就可以用该表进行匹配。

我们需要做的就是对于 PMT 的求解过程稍作修改，例如将原数组改为主字符串以及一些其他的修改。具体代码如下（这里变量的命名参考 LC28 ）：

```python
def kmp(haystack: str, needle: str):
    n = len(haystack)
    m = len(needle)
    def pmt(s):
        # refer from section 1.2
        pass

    ans = pmt(needle) # pmt
    i, j = 0, 0
    ans = pmt(needle) # pmt
    i, j = 0, 0
    while i < n:
        if haystack[i] == needle[j]: # matched
            j += 1
            i += 1
        elif j == 0: # not match, j == 0
            i += 1
        else: # not match, general
            j = ans[j - 1]
        if j == m:
            return i - j
    return -1
```

和前面类似，该算法的时间复杂度为 $O(m+n)$.

## 3. 应用

- [28. Implement strStr()](https://leetcode-cn.com/problems/implement-strstr/)

    这道题是很典型的可以应用 KMP 算法的实例。详细代码见上，注意需要增加对于 `needle == ""` 的讨论。

- [214. Shortest Palindrome](https://leetcode-cn.com/problems/shortest-palindrome/)

    这道题直译一下就是，找到 `s[::-1]` 的后缀和 `s` 的前缀的最长公共部分，那么很明显可以想到这和 PMT 的定义十分相似，因此我们可以用求解 PMT 的步骤来解决这道题。

    但是需要注意的是，如果不加分割地求解 `s + s[::-1]` 的 PMT 数组，得到的结果可能会超过 `len(s)`, 因此在这里我们可以在 `s` 和 `s[::-1]` 之间添加一个不出现在 `s` 字符集中的字符，例如 `'#'`, 这样计算 PMT 数组的时候就不会出现越界的问题了。


## 参考文献

- CLRS, Chapter 32, Section 4.

- [如何更好地理解和掌握 KMP 算法? - 海纳的回答 - 知乎](https://www.zhihu.com/question/21923021/answer/281346746)

