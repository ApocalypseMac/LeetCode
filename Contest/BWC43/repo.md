lc BWC 43

7/19

0:08:39

T3 一开始没发现可以按顺序找最大的，想起来之后来不及改了，比赛结束的时候算法还是假的（

------

- 5633 easy

    找规律，模拟累加。

- 5634 medium

    首先可以证明任何一段连续的 `[ab]+` 序列，不管删除方法如何，最多删除的次数是一定的。那么就可以贪心，优先贪心删除较大分值的，然后贪心删除最小的。将字符串转化为数组（栈），两次处理并记录分数即可。

- 5635 medium

    首先，想遍历所有解的复杂度是阶乘的，数据范围过大因此不能遍历全部。那么考虑字典序最大，我们可以通过改变递归回溯的顺序使得第一个结果是符合要求的。那么就需要从左到右递归序列的空位，并从高到低尝试填数。这里数字的选取状态可以用二进制来表示，并且要考虑是 `1` 的特殊情况（只填一个），并用一个全局变量监测结果是否找到。

- 5636 hard

    首先可以统计每一个节点的出现次数 `cnt`. 考虑到根必然存在，因此必然有至少一个节点的 `cnt = n - 1`. 如果不存在，那么方案为 `0`, 提前返回 `0`. 

    接下来先将（如果存在）的返回结果 `res` 置为 `1`. 考虑如果有一个数对 `u, v`, 满足 `cnt[u] == cnt[v]`, 那么在建树过程中（如果方案存在）那么两者可以交换位置，即会有多个方案，此时可以把 `res` 修改为 `2`. 而如果 `cnt[u] > cnt[v]`, 则 `u` 必为 `v` 的祖先，且有除了 `v` 以外的其他子树。因此我们可以按照 `cnt` 倒序排序节点然后尝试恢复树。

    用 `vis` 记录访问过的节点，用 `pa` 记录当前**已知**该节点**距离最近**的祖先（最初全部置为 `root`）。遍历排序后的 `cnt`, 对于每个当前节点 `u`, 遍历所有有配对关系且未访问的节点`v`, 此时这些节点要么可互换要么 `v` 在 `u` 的子树中（事实上，前者由于我们按顺序恢复树，那么在此种顺序下也满足后者的条件）。那么必然有 `pa[u] == pa[v]`, 如果不满足则说明无法恢复，提前返回 `0`. 遍历完成后返回 `res` 即可。

------

就是人菜（