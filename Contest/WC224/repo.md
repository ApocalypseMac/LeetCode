# lc weekly contest 224

12/19

0:31:52

T3 想了好久， T4 算法写假了，一直错隐藏用例（

------

- 5653 easy

    按要求找到最大值并依次判断。

- 5243 medium

    遍历不同的数对，统计不同乘积的数目。对于最后的元组数目，假设某个乘积的数对有 `k` 个，那么可以贡献 `8*k*(k-1)` 个元组，统计求和即可。

- 5655 medium

    思路类似于 LC85 一维转换为二维的思路，对于每一行，统计每列以该行结尾的连续 `1` 的数目（可以一次遍历预处理），然后排序并维护最大可能的矩形值（行数*最小的高度）。

- 5529 hard

    博弈论 DP 题目。基本的状态包括老鼠和猫的坐标以及当前玩家（或者轮数）。如果有轮数上限可以用带轮数的记忆化搜索解决（但是这里 `Python` `128` （假设的上限）在超时边缘）。

    另外一种算法是对于所有状态（老鼠坐标，猫坐标，当前玩家）进行拓扑排序。此时的拓扑排序是从已知的（当前玩家）必胜/必败态**逆向**进行转移。

    利用的两个原则是：

    1. 必败态的所有邻居都是必胜态。

    2. 必胜态必定至少有一个邻居为必败态。

    最终任意一个态会有必胜/必败/平局（出现环）三种状态，按要求输出结果即可。

------