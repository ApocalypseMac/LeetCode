# LCCUP 2020 Group Competition

- T1 easy 2pt

    首先排除边界情况，然后对于涂的行数进行遍历，符合要求（再涂某几列即可满足要求）就将对应的组合数加入计数。

- T2 medium 4pt

    模拟洗牌过程，通过第一次洗牌确定 `k`, 然后对于剩下的部分继续模拟，如果不符合要求就返回。

- T3 hard 6pt

    首先可以将问题转化，通过将每个数减去其下标，即可将问题变成如何操作使得子数组数字一样。可以证明，在取中位数（此处如果不是整数则向下或者向上取整）时，加减操作总数最少。因此问题就变成了 LC295 数据流的中位数。双堆 / `multiset` 解决。

- T4 hard 7pt

    方法很多，列两种自己差不多会的方法。
    
    1. 记忆化搜索， `dp[a][b][c][d][e]` 表示还能用 `1, 2, 3, 4, 5` 次字符的种类数，然后列转移方程搜索即可，注意边界条件（超过了就是 `0`, 恰好用完是 `1`）。
    2. EGF（指数生成函数）， 亦即组合问题的排列母函数。对于每个字母，在数量上限为 `k` 时， 其母函数为 $f(x) = \sum^k_{i=0} \frac{x^i}{i!}$; 对于 26 个字母，其母函数为 $g(x) = f(x)^{26}$; 而对于取 `n` 个字母的情况，就是 $x^n$ 项的系数乘上全排列数 $n!$. 对于分母同余，计算逆即可（可以用费马小定理或者其他方法）。

- T5 hard 9pt

    首先可以证明，监视器最优解一定全部在叶子节点。其次，对于所有度为 2 的节点，只需要两边的某一个叶节点有监视器即可区分，因此可以先删去。此时整个图只剩下度数为 1 和 3 的节点。对于度数为 3 的节点，其邻接节点只有度数 1 （叶）或者 3 （非叶）两种情况，此时采用分割的思路，我们只考虑邻接的叶节点（邻接的非叶节点默认已经处理），如果邻接 `n` 个叶节点，可以证明需要在其中 `n-1` 个中装上监视器即可区分。这样，遍历所有节点，就可以知道需要监视器的最小数目。

- T6 hard 9pt
- 
    格点数总共 `2 * (m + n)`, 考虑不同的方向，光线总共有 `4 * (m + n) - 4` 种状态，是有限的，因此一定会存在环。那么我们可以在预处理时处理所有状态转移形成的环（状态由格点和出射角度唯一定义）。对于每一个环路，建立一个 `set / map` 来记录会射出的状态（打开的格点），这样对于每次入射，只需要在 `set / map` 中搜索下一个打开的状态（格点）即可。`Python` 中可以用 `sortedcontainers` 库中的 `SortedList / SortedDict` 类来实现。细节相对比较复杂，思路在确定后比较直接。