# lc weekly contest 206

18/18

1:00:03 + 2 errors = 1:10:03

第二题报错之后改循环范围脑抽了又错了一次，总体来说还算可以。

------

- 5511 easy 
    暴力两次遍历，第一次算行列和，第二次判断位置是否符合要求。

- 5512 middle
    首先将邻接表转换为邻接矩阵（关系权重按照递减数列排序即可）存储关系权重（方便判断任意两点之间关系），并用 hash table (list) 存储每个点的配对点。然后用集合存储不开心的朋友，遍历每个点和可能存在符合题意关系的另一个点。注意这里的关系是具有对称性的，因此每次更新集合都是成对的（但是要注意 **可能会有一个点已经在集合中**，使得最后个数为奇数。）总时间复杂度 $O(n^3)$ 是可以通过的。

- 5513 middle
    完全图 MST, 直接上 Kruskal 板子。注意距离定义，没了。

- 5514 hard
    考虑遍历每种方案显然是不现实的。但是可以看出，每次子串操作需要保序，因此可以从序入手。这里的“序”是什么，就是对于一个数它后面比它大的数字的数量；可以很容易看出，无论怎么操作（假使我们知道每个数移动结束的位置），它的序一定是只增不减的。

    这样思路就很明确了，首先去掉数字频率不一样的 case, 然后求后缀和（对于每个位置，其后缀中大于等于某个数的数字数目），再对每个数字求它的序并**按数字**保存。最后判断的时候对每个数的序数组排序（因为实际上不知道具体的对应，我们就假设最弱条件），看是否严格大于等于即可。
    
    PS: 这里的严格证明还没有想到，但是按理说应该是对的（？

------

想说啥？没了。
