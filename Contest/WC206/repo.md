# lc weekly contest 206

18/18

1:00:03 + 2 errors = 1:10:03

第二题报错之后改循环范围脑抽了又错了一次，总体来说还算可以。

------

- 5511 easy 
    暴力两次遍历，第一次算行列和，第二次判断位置是否符合要求。

- 5512 middle
    首先将邻接表转换为邻接矩阵（关系权重按照递减数列排序即可）存储关系权重（方便判断任意两点之间关系），并用 hash table (list) 存储每个点的配对点。然后用集合存储不开心的朋友，遍历每个点和可能存在符合题意关系的另一个点。注意这里的关系是具有对称性的，因此每次更新集合都是成对的（但是要注意 **可能会有一个点已经在集合中**，使得最后个数为奇数。）总时间复杂度 $O(n^3)$ 是可以通过的。

- 5513 middle
    完全图 MST, 直接上 Kruskal 板子。注意距离定义，没了。

- 5514 hard
    EDIT: 比赛中 AC 的方法有比较大的问题，题解已更新

    考虑遍历每种方案显然是不现实的。但是可以看出，每次子串操作需要保序，因此可以从序入手。这里的“序”是什么，从反向入手，就是对于一对数字逆序出现的数量（特定**逆序对**的数量）；可以很容易看出，无论怎么操作（假使我们知道每个数移动结束的位置），逆序对的数量一定是只减不增的。

    这样思路就很明确了，首先去掉数字频率不一样的 case, 然后对每个数字求它的逆序对数目并**按数字**逐个比较。

    事实上，为了简化，也可以利用多个队列存储字符串 s 的数字位置，然后遍历 t 并且看是否有多出来的逆序对（对于每个数字，遍历比其小的数看看有没有 s 中位置靠前未取到的数），如有则显然为错。
    
    PS: 这里的严格证明还没有想到，但是按理说应该是对的（？

------

想说啥？没了。
