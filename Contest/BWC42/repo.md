# lc BWC 42

18/18

1:08:10 + 3 errors = 1:23:10

手残+脑残基本没救了

------

- 5621 easy

    模拟。

- 5622 medium

    模拟。

- 5623 medium

    变换有两种， `00` 到 `10` 与 `10` 到 `01`. 考虑数值改变，前者增加后者减少；考虑 `1` 的数量改变，前者增加后者不变。

    首先，可以证明，最优解一定至多只有一个 `0`, 可以用反证法构造证明。因此对于至多有一个 `0` 的情况，不做改动就是最优解。

    其次确定其余情况中唯一 `0` 的位置。考虑任意两个相邻的 `0`, 若中间没有 `1` 即可直接变为 `10`, 若中间有 `1`, 先对后一个做第二种操作，待相邻后进行第一种操作，即 `011110 -> 101111`. 可以证明这种方案是最优的。那么对于字符串中的所有 `0` 按顺序处理即可。（另一种直接的方法是将第一个 `0` 后的所有 `1` 移到尾部，然后对中间连续的 `0` 进行第一种操作）

- 5624 hard

    最方便的方法是考虑相邻的 `k` 个 `1` 合并的过程。那么就与 LCP24 类似了，在合并前后中位数相等的时候花费最小。维护最小花费更新即可。为了减少计算可以使用前缀和技巧。

    还有一种方法是对于每个窗口考虑其中的 `m` 个 `0` 分别有多少由左右两边的 `1` 提供。假设左边提供 `l` 个最近的 `1`, 那么花费相对于 `l` 先减后增（或单调）。对于这种凸函数可以通过三分求解。同样在计算时需要用前缀和来优化。

------
