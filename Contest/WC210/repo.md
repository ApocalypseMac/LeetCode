# lc weekly contest 210

18/18

0:40:38 + 2 errors = 0:50:38

睡过头了就没参加，摸了一把虚拟竞赛（

------

- 5535 easy
    说那么多都是假的，括号深度，栈的思维。

- 5536 medium
    每个点算边数，每两个点建立表格判断是否直连，最后遍历维护不重复的最大值即可。

- 5537 medium
    直觉是暴力比较，但是数据范围不允许。事实上，我们可以分别将两个字符串分成三个部分：中心对称的部分和等长的左右两边。这样，只要对于任意一个字符串，其左右任一部分替换成另一个字符串的相应部分，形成的新字符串回文，即可符合要求。可以证明这样贪心的选取方案一定是满足要求的。

    手残脑残搞了两个 error, 不应该。


- 5538 hard
    节点最多 `n = 15` 个，因此可以直接位运算暴力遍历所有的树。首先预处理邻接表和每两点之间的最短距离（对于树就是距离），然后（回溯）枚举子集求解。递归中维护几个变量， `mask` 亦即树的形状，和树相邻的点集，树的直径，每次递归中从邻域中心选取点。

------

遇到困难，睡大觉（
