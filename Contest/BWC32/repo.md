# lc BWC 32

18/18
0:48:25 + 6 errors = 1:18:25

简要写个repo

有惊无险地做完了四道题，居然罚时了六次，还是静不下心，需要修炼

------

下面说题目

- 5468 easy

    签到题，注意如果整数大于数组的最大元素减去数组元素数目，那么就直接从数组最大元素开始加，其他情况套个指针遍历计数即可。

- 5469 middle

    脑子不好几个变量打错了，贡献了三个error（9分钟的时候罚时已经15分钟了）。

    轮换操作的次数显然是模26余0-25，那么建个26长度的数组，index是余数，element是频率，最后看每个余数下的操作数目是否超过k.

- 5470 middle

    傻逼题，题意没讲清楚，卡了半天（两个error）直接做第四题了。后来改了一万次未果，最后终于凑数字猜出来他要我干啥了。结果忘了注释print由贡献了一个output limit exceed, 脑壳痛。

    EDIT: 刚才看了一下，题目好像没问题，每个左括号必须在 **对应** 的 **连续** 两个右括号前（总之不管题目说的对不对我阅读理解零分完事了）

    用一个数curr表示栈，碰到左括号+2，右括号-1，碰到第一个左括号的时候检测一下值，奇数的话先补个右括号再说（对应），然后curr必然为偶数，除以2取负号就是需要补的左括号数量，完事之后置零curr. 结尾再判断一次，正的补右括号，负的搞左括号（注意奇数情况要先补一个 '()' ）。

    最后引用一句话，
    > “人一生未闭合的左括号数量是有限的，谁先用完谁先走。”      ---@ooxxcc

- 5485 hard

    真的比第三题简单（大嘘）

    首先，回文，就是至多有一个字符频率为1. 子串，那就无脑前缀和。字符集是数字，数组长度10. 数组太占空间了对吧，位运算。

    本来准备开一个1024的数组的，后来想了一下简单case时间会很长，那就老老实实dict. 存啥，当然是第一次和最后一次出现的下标。

    状态用10bits整数存储，先存初始状态，然后每次迭代取异或，更新dict. 最后遍历一下dict, 先算没有奇数元素的情况（比较自己），然后算一个奇数元素的情况（每位取异或，求互相最大值最小值之差），维护个全局最大值，完事。

    一遍AC, 快乐.jpg

------

calm down and relax

送给明天周赛时候的我
